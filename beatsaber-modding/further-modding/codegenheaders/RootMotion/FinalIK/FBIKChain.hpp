// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "extern/beatsaber-hook/shared/utils/typedefs.h"
#include <initializer_list>
#include "extern/beatsaber-hook/shared/utils/byref.hpp"
// Including type: RootMotion.FinalIK.IKSolver
#include "RootMotion/FinalIK/IKSolver.hpp"
// Including type: System.Enum
#include "System/Enum.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "extern/beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: RootMotion::FinalIK
namespace RootMotion::FinalIK {
  // Forward declaring type: IKConstraintBend
  class IKConstraintBend;
  // Forward declaring type: IKSolverFullBody
  class IKSolverFullBody;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
  // Skipping declaration: Vector3 because it is already included!
}
// Completed forward declares
// Type namespace: RootMotion.FinalIK
namespace RootMotion::FinalIK {
  // Size: 0x84
  #pragma pack(push, 1)
  // Autogenerated type: RootMotion.FinalIK.FBIKChain
  // [TokenAttribute] Offset: FFFFFFFF
  class FBIKChain : public ::Il2CppObject {
    public:
    // Nested type: RootMotion::FinalIK::FBIKChain::ChildConstraint
    class ChildConstraint;
    // Nested type: RootMotion::FinalIK::FBIKChain::Smoothing
    struct Smoothing;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing
    // [TokenAttribute] Offset: FFFFFFFF
    struct Smoothing/*, public System::Enum*/ {
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // Creating value type constructor for type: Smoothing
      constexpr Smoothing(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator System::Enum
      operator System::Enum() noexcept {
        return *reinterpret_cast<System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing None
      static constexpr const int None = 0;
      // Get static field: static public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing None
      static RootMotion::FinalIK::FBIKChain::Smoothing _get_None();
      // Set static field: static public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing None
      static void _set_None(RootMotion::FinalIK::FBIKChain::Smoothing value);
      // static field const value: static public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing Exponential
      static constexpr const int Exponential = 1;
      // Get static field: static public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing Exponential
      static RootMotion::FinalIK::FBIKChain::Smoothing _get_Exponential();
      // Set static field: static public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing Exponential
      static void _set_Exponential(RootMotion::FinalIK::FBIKChain::Smoothing value);
      // static field const value: static public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing Cubic
      static constexpr const int Cubic = 2;
      // Get static field: static public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing Cubic
      static RootMotion::FinalIK::FBIKChain::Smoothing _get_Cubic();
      // Set static field: static public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing Cubic
      static void _set_Cubic(RootMotion::FinalIK::FBIKChain::Smoothing value);
      // Get instance field reference: public System.Int32 value__
      int& dyn_value__();
    }; // RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing
    #pragma pack(pop)
    static check_size<sizeof(FBIKChain::Smoothing), 0 + sizeof(int)> __RootMotion_FinalIK_FBIKChain_SmoothingSizeCheck;
    static_assert(sizeof(FBIKChain::Smoothing) == 0x4);
    // [RangeAttribute] Offset: 0xE2C748
    // public System.Single pin
    // Size: 0x4
    // Offset: 0x10
    float pin;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0xE2C760
    // public System.Single pull
    // Size: 0x4
    // Offset: 0x14
    float pull;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0xE2C778
    // public System.Single push
    // Size: 0x4
    // Offset: 0x18
    float push;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0xE2C790
    // public System.Single pushParent
    // Size: 0x4
    // Offset: 0x1C
    float pushParent;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0xE2C7A8
    // public System.Single reach
    // Size: 0x4
    // Offset: 0x20
    float reach;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing reachSmoothing
    // Size: 0x4
    // Offset: 0x24
    RootMotion::FinalIK::FBIKChain::Smoothing reachSmoothing;
    // Field size check
    static_assert(sizeof(RootMotion::FinalIK::FBIKChain::Smoothing) == 0x4);
    // public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing pushSmoothing
    // Size: 0x4
    // Offset: 0x28
    RootMotion::FinalIK::FBIKChain::Smoothing pushSmoothing;
    // Field size check
    static_assert(sizeof(RootMotion::FinalIK::FBIKChain::Smoothing) == 0x4);
    // Padding between fields: pushSmoothing and: nodes
    char __padding6[0x4] = {};
    // public RootMotion.FinalIK.IKSolver/RootMotion.FinalIK.Node[] nodes
    // Size: 0x8
    // Offset: 0x30
    ::Array<RootMotion::FinalIK::IKSolver::Node*>* nodes;
    // Field size check
    static_assert(sizeof(::Array<RootMotion::FinalIK::IKSolver::Node*>*) == 0x8);
    // public System.Int32[] children
    // Size: 0x8
    // Offset: 0x38
    ::Array<int>* children;
    // Field size check
    static_assert(sizeof(::Array<int>*) == 0x8);
    // public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.ChildConstraint[] childConstraints
    // Size: 0x8
    // Offset: 0x40
    ::Array<RootMotion::FinalIK::FBIKChain::ChildConstraint*>* childConstraints;
    // Field size check
    static_assert(sizeof(::Array<RootMotion::FinalIK::FBIKChain::ChildConstraint*>*) == 0x8);
    // public RootMotion.FinalIK.IKConstraintBend bendConstraint
    // Size: 0x8
    // Offset: 0x48
    RootMotion::FinalIK::IKConstraintBend* bendConstraint;
    // Field size check
    static_assert(sizeof(RootMotion::FinalIK::IKConstraintBend*) == 0x8);
    // private System.Single rootLength
    // Size: 0x4
    // Offset: 0x50
    float rootLength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean initiated
    // Size: 0x1
    // Offset: 0x54
    bool initiated;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: initiated and: length
    char __padding12[0x3] = {};
    // private System.Single length
    // Size: 0x4
    // Offset: 0x58
    float length;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single distance
    // Size: 0x4
    // Offset: 0x5C
    float distance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private RootMotion.FinalIK.IKSolver/RootMotion.FinalIK.Point p
    // Size: 0x8
    // Offset: 0x60
    RootMotion::FinalIK::IKSolver::Point* p;
    // Field size check
    static_assert(sizeof(RootMotion::FinalIK::IKSolver::Point*) == 0x8);
    // private System.Single reachForce
    // Size: 0x4
    // Offset: 0x68
    float reachForce;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single pullParentSum
    // Size: 0x4
    // Offset: 0x6C
    float pullParentSum;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single[] crossFades
    // Size: 0x8
    // Offset: 0x70
    ::Array<float>* crossFades;
    // Field size check
    static_assert(sizeof(::Array<float>*) == 0x8);
    // private System.Single sqrMag1
    // Size: 0x4
    // Offset: 0x78
    float sqrMag1;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single sqrMag2
    // Size: 0x4
    // Offset: 0x7C
    float sqrMag2;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single sqrMagDif
    // Size: 0x4
    // Offset: 0x80
    float sqrMagDif;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Creating value type constructor for type: FBIKChain
    FBIKChain(float pin_ = {}, float pull_ = {}, float push_ = {}, float pushParent_ = {}, float reach_ = {}, RootMotion::FinalIK::FBIKChain::Smoothing reachSmoothing_ = {}, RootMotion::FinalIK::FBIKChain::Smoothing pushSmoothing_ = {}, ::Array<RootMotion::FinalIK::IKSolver::Node*>* nodes_ = {}, ::Array<int>* children_ = {}, ::Array<RootMotion::FinalIK::FBIKChain::ChildConstraint*>* childConstraints_ = {}, RootMotion::FinalIK::IKConstraintBend* bendConstraint_ = {}, float rootLength_ = {}, bool initiated_ = {}, float length_ = {}, float distance_ = {}, RootMotion::FinalIK::IKSolver::Point* p_ = {}, float reachForce_ = {}, float pullParentSum_ = {}, ::Array<float>* crossFades_ = {}, float sqrMag1_ = {}, float sqrMag2_ = {}, float sqrMagDif_ = {}) noexcept : pin{pin_}, pull{pull_}, push{push_}, pushParent{pushParent_}, reach{reach_}, reachSmoothing{reachSmoothing_}, pushSmoothing{pushSmoothing_}, nodes{nodes_}, children{children_}, childConstraints{childConstraints_}, bendConstraint{bendConstraint_}, rootLength{rootLength_}, initiated{initiated_}, length{length_}, distance{distance_}, p{p_}, reachForce{reachForce_}, pullParentSum{pullParentSum_}, crossFades{crossFades_}, sqrMag1{sqrMag1_}, sqrMag2{sqrMag2_}, sqrMagDif{sqrMagDif_} {}
    // static field const value: static private System.Single maxLimbLength
    static constexpr const float maxLimbLength = 0.99999;
    // Get static field: static private System.Single maxLimbLength
    static float _get_maxLimbLength();
    // Set static field: static private System.Single maxLimbLength
    static void _set_maxLimbLength(float value);
    // Get instance field reference: public System.Single pin
    float& dyn_pin();
    // Get instance field reference: public System.Single pull
    float& dyn_pull();
    // Get instance field reference: public System.Single push
    float& dyn_push();
    // Get instance field reference: public System.Single pushParent
    float& dyn_pushParent();
    // Get instance field reference: public System.Single reach
    float& dyn_reach();
    // Get instance field reference: public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing reachSmoothing
    RootMotion::FinalIK::FBIKChain::Smoothing& dyn_reachSmoothing();
    // Get instance field reference: public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.Smoothing pushSmoothing
    RootMotion::FinalIK::FBIKChain::Smoothing& dyn_pushSmoothing();
    // Get instance field reference: public RootMotion.FinalIK.IKSolver/RootMotion.FinalIK.Node[] nodes
    ::Array<RootMotion::FinalIK::IKSolver::Node*>*& dyn_nodes();
    // Get instance field reference: public System.Int32[] children
    ::Array<int>*& dyn_children();
    // Get instance field reference: public RootMotion.FinalIK.FBIKChain/RootMotion.FinalIK.ChildConstraint[] childConstraints
    ::Array<RootMotion::FinalIK::FBIKChain::ChildConstraint*>*& dyn_childConstraints();
    // Get instance field reference: public RootMotion.FinalIK.IKConstraintBend bendConstraint
    RootMotion::FinalIK::IKConstraintBend*& dyn_bendConstraint();
    // Get instance field reference: private System.Single rootLength
    float& dyn_rootLength();
    // Get instance field reference: private System.Boolean initiated
    bool& dyn_initiated();
    // Get instance field reference: private System.Single length
    float& dyn_length();
    // Get instance field reference: private System.Single distance
    float& dyn_distance();
    // Get instance field reference: private RootMotion.FinalIK.IKSolver/RootMotion.FinalIK.Point p
    RootMotion::FinalIK::IKSolver::Point*& dyn_p();
    // Get instance field reference: private System.Single reachForce
    float& dyn_reachForce();
    // Get instance field reference: private System.Single pullParentSum
    float& dyn_pullParentSum();
    // Get instance field reference: private System.Single[] crossFades
    ::Array<float>*& dyn_crossFades();
    // Get instance field reference: private System.Single sqrMag1
    float& dyn_sqrMag1();
    // Get instance field reference: private System.Single sqrMag2
    float& dyn_sqrMag2();
    // Get instance field reference: private System.Single sqrMagDif
    float& dyn_sqrMagDif();
    // public System.Void .ctor(System.Single pin, System.Single pull, params UnityEngine.Transform[] nodeTransforms)
    // Offset: 0x1D38E30
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static FBIKChain* New_ctor(float pin, float pull, ::Array<UnityEngine::Transform*>* nodeTransforms) {
      static auto ___internal__logger = ::Logger::get().WithContext("RootMotion::FinalIK::FBIKChain::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<FBIKChain*, creationType>(pin, pull, nodeTransforms)));
    }
    // Creating initializer_list -> params proxy for: System.Void .ctor(System.Single pin, System.Single pull, params UnityEngine.Transform[] nodeTransforms)
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static FBIKChain* New_ctor(float pin, float pull, std::initializer_list<UnityEngine::Transform*> nodeTransforms) {
      return New_ctor<creationType>(pin, pull, ::Array<UnityEngine::Transform*>::New(nodeTransforms));
    }
    // Creating TArgs -> initializer_list proxy for: System.Void .ctor(System.Single pin, System.Single pull, params UnityEngine.Transform[] nodeTransforms)
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary, class ...TParams>
    static FBIKChain* New_ctor(float pin, float pull, TParams&&... nodeTransforms) {
      return New_ctor<creationType>(pin, pull, {nodeTransforms...});
    }
    // public System.Void SetNodes(params UnityEngine.Transform[] boneTransforms)
    // Offset: 0x1D38F3C
    void SetNodes(::Array<UnityEngine::Transform*>* boneTransforms);
    // Creating initializer_list -> params proxy for: System.Void SetNodes(params UnityEngine.Transform[] boneTransforms)
    void SetNodes(std::initializer_list<UnityEngine::Transform*> boneTransforms);
    // Creating TArgs -> initializer_list proxy for: System.Void SetNodes(params UnityEngine.Transform[] boneTransforms)
    template<class ...TParams>
    void SetNodes(TParams&&... boneTransforms) {
      SetNodes({boneTransforms...});
    }
    // public System.Int32 GetNodeIndex(UnityEngine.Transform boneTransform)
    // Offset: 0x1D39060
    int GetNodeIndex(UnityEngine::Transform* boneTransform);
    // public System.Boolean IsValid(ref System.String message)
    // Offset: 0x1D3913C
    bool IsValid(ByRef<::Il2CppString*> message);
    // public System.Void Initiate(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1D39240
    void Initiate(RootMotion::FinalIK::IKSolverFullBody* solver);
    // public System.Void ReadPose(RootMotion.FinalIK.IKSolverFullBody solver, System.Boolean fullBody)
    // Offset: 0x1D39960
    void ReadPose(RootMotion::FinalIK::IKSolverFullBody* solver, bool fullBody);
    // private System.Void CalculateBoneLengths(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1D393D0
    void CalculateBoneLengths(RootMotion::FinalIK::IKSolverFullBody* solver);
    // public System.Void Reach(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1D3A04C
    void Reach(RootMotion::FinalIK::IKSolverFullBody* solver);
    // public UnityEngine.Vector3 Push(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1D3A3F0
    UnityEngine::Vector3 Push(RootMotion::FinalIK::IKSolverFullBody* solver);
    // public System.Void SolveTrigonometric(RootMotion.FinalIK.IKSolverFullBody solver, System.Boolean calculateBendDirection)
    // Offset: 0x1D3A7D4
    void SolveTrigonometric(RootMotion::FinalIK::IKSolverFullBody* solver, bool calculateBendDirection);
    // public System.Void Stage1(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1D3AD58
    void Stage1(RootMotion::FinalIK::IKSolverFullBody* solver);
    // public System.Void Stage2(RootMotion.FinalIK.IKSolverFullBody solver, UnityEngine.Vector3 position)
    // Offset: 0x1D3B328
    void Stage2(RootMotion::FinalIK::IKSolverFullBody* solver, UnityEngine::Vector3 position);
    // public System.Void SolveConstraintSystems(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1D3B5C0
    void SolveConstraintSystems(RootMotion::FinalIK::IKSolverFullBody* solver);
    // private UnityEngine.Vector3 SolveFABRIKJoint(UnityEngine.Vector3 pos1, UnityEngine.Vector3 pos2, System.Single length)
    // Offset: 0x1D3B220
    UnityEngine::Vector3 SolveFABRIKJoint(UnityEngine::Vector3 pos1, UnityEngine::Vector3 pos2, float length);
    // protected UnityEngine.Vector3 GetDirToBendPoint(UnityEngine.Vector3 direction, UnityEngine.Vector3 bendDirection, System.Single directionMagnitude)
    // Offset: 0x1D3AB40
    UnityEngine::Vector3 GetDirToBendPoint(UnityEngine::Vector3 direction, UnityEngine::Vector3 bendDirection, float directionMagnitude);
    // private System.Void SolveChildConstraints(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1D3B1A8
    void SolveChildConstraints(RootMotion::FinalIK::IKSolverFullBody* solver);
    // private System.Void SolveLinearConstraint(RootMotion.FinalIK.IKSolver/RootMotion.FinalIK.Node node1, RootMotion.FinalIK.IKSolver/RootMotion.FinalIK.Node node2, System.Single crossFade, System.Single distance)
    // Offset: 0x1D3B6A8
    void SolveLinearConstraint(RootMotion::FinalIK::IKSolver::Node* node1, RootMotion::FinalIK::IKSolver::Node* node2, float crossFade, float distance);
    // public System.Void ForwardReach(UnityEngine.Vector3 position)
    // Offset: 0x1D3B0C8
    void ForwardReach(UnityEngine::Vector3 position);
    // private System.Void BackwardReach(UnityEngine.Vector3 position)
    // Offset: 0x1D3B4A8
    void BackwardReach(UnityEngine::Vector3 position);
    // public System.Void .ctor()
    // Offset: 0x1D38D64
    // Implemented from: System.Object
    // Base method: System.Void Object::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static FBIKChain* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("RootMotion::FinalIK::FBIKChain::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<FBIKChain*, creationType>()));
    }
  }; // RootMotion.FinalIK.FBIKChain
  #pragma pack(pop)
  static check_size<sizeof(FBIKChain), 128 + sizeof(float)> __RootMotion_FinalIK_FBIKChainSizeCheck;
  static_assert(sizeof(FBIKChain) == 0x84);
}
DEFINE_IL2CPP_ARG_TYPE(RootMotion::FinalIK::FBIKChain*, "RootMotion.FinalIK", "FBIKChain");
DEFINE_IL2CPP_ARG_TYPE(RootMotion::FinalIK::FBIKChain::Smoothing, "RootMotion.FinalIK", "FBIKChain/Smoothing");
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::SetNodes
// Il2CppName: SetNodes
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(::Array<UnityEngine::Transform*>*)>(&RootMotion::FinalIK::FBIKChain::SetNodes)> {
  static const MethodInfo* get() {
    static auto* boneTransforms = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "Transform"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "SetNodes", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{boneTransforms});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::GetNodeIndex
// Il2CppName: GetNodeIndex
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (RootMotion::FinalIK::FBIKChain::*)(UnityEngine::Transform*)>(&RootMotion::FinalIK::FBIKChain::GetNodeIndex)> {
  static const MethodInfo* get() {
    static auto* boneTransform = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "GetNodeIndex", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{boneTransform});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::IsValid
// Il2CppName: IsValid
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (RootMotion::FinalIK::FBIKChain::*)(ByRef<::Il2CppString*>)>(&RootMotion::FinalIK::FBIKChain::IsValid)> {
  static const MethodInfo* get() {
    static auto* message = &::il2cpp_utils::GetClassFromName("System", "String")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "IsValid", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{message});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::Initiate
// Il2CppName: Initiate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(RootMotion::FinalIK::IKSolverFullBody*)>(&RootMotion::FinalIK::FBIKChain::Initiate)> {
  static const MethodInfo* get() {
    static auto* solver = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolverFullBody")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "Initiate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{solver});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::ReadPose
// Il2CppName: ReadPose
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(RootMotion::FinalIK::IKSolverFullBody*, bool)>(&RootMotion::FinalIK::FBIKChain::ReadPose)> {
  static const MethodInfo* get() {
    static auto* solver = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolverFullBody")->byval_arg;
    static auto* fullBody = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "ReadPose", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{solver, fullBody});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::CalculateBoneLengths
// Il2CppName: CalculateBoneLengths
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(RootMotion::FinalIK::IKSolverFullBody*)>(&RootMotion::FinalIK::FBIKChain::CalculateBoneLengths)> {
  static const MethodInfo* get() {
    static auto* solver = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolverFullBody")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "CalculateBoneLengths", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{solver});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::Reach
// Il2CppName: Reach
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(RootMotion::FinalIK::IKSolverFullBody*)>(&RootMotion::FinalIK::FBIKChain::Reach)> {
  static const MethodInfo* get() {
    static auto* solver = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolverFullBody")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "Reach", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{solver});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::Push
// Il2CppName: Push
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Vector3 (RootMotion::FinalIK::FBIKChain::*)(RootMotion::FinalIK::IKSolverFullBody*)>(&RootMotion::FinalIK::FBIKChain::Push)> {
  static const MethodInfo* get() {
    static auto* solver = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolverFullBody")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "Push", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{solver});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::SolveTrigonometric
// Il2CppName: SolveTrigonometric
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(RootMotion::FinalIK::IKSolverFullBody*, bool)>(&RootMotion::FinalIK::FBIKChain::SolveTrigonometric)> {
  static const MethodInfo* get() {
    static auto* solver = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolverFullBody")->byval_arg;
    static auto* calculateBendDirection = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "SolveTrigonometric", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{solver, calculateBendDirection});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::Stage1
// Il2CppName: Stage1
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(RootMotion::FinalIK::IKSolverFullBody*)>(&RootMotion::FinalIK::FBIKChain::Stage1)> {
  static const MethodInfo* get() {
    static auto* solver = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolverFullBody")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "Stage1", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{solver});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::Stage2
// Il2CppName: Stage2
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(RootMotion::FinalIK::IKSolverFullBody*, UnityEngine::Vector3)>(&RootMotion::FinalIK::FBIKChain::Stage2)> {
  static const MethodInfo* get() {
    static auto* solver = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolverFullBody")->byval_arg;
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "Stage2", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{solver, position});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::SolveConstraintSystems
// Il2CppName: SolveConstraintSystems
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(RootMotion::FinalIK::IKSolverFullBody*)>(&RootMotion::FinalIK::FBIKChain::SolveConstraintSystems)> {
  static const MethodInfo* get() {
    static auto* solver = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolverFullBody")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "SolveConstraintSystems", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{solver});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::SolveFABRIKJoint
// Il2CppName: SolveFABRIKJoint
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Vector3 (RootMotion::FinalIK::FBIKChain::*)(UnityEngine::Vector3, UnityEngine::Vector3, float)>(&RootMotion::FinalIK::FBIKChain::SolveFABRIKJoint)> {
  static const MethodInfo* get() {
    static auto* pos1 = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* pos2 = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* length = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "SolveFABRIKJoint", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pos1, pos2, length});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::GetDirToBendPoint
// Il2CppName: GetDirToBendPoint
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<UnityEngine::Vector3 (RootMotion::FinalIK::FBIKChain::*)(UnityEngine::Vector3, UnityEngine::Vector3, float)>(&RootMotion::FinalIK::FBIKChain::GetDirToBendPoint)> {
  static const MethodInfo* get() {
    static auto* direction = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* bendDirection = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* directionMagnitude = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "GetDirToBendPoint", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{direction, bendDirection, directionMagnitude});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::SolveChildConstraints
// Il2CppName: SolveChildConstraints
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(RootMotion::FinalIK::IKSolverFullBody*)>(&RootMotion::FinalIK::FBIKChain::SolveChildConstraints)> {
  static const MethodInfo* get() {
    static auto* solver = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolverFullBody")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "SolveChildConstraints", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{solver});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::SolveLinearConstraint
// Il2CppName: SolveLinearConstraint
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(RootMotion::FinalIK::IKSolver::Node*, RootMotion::FinalIK::IKSolver::Node*, float, float)>(&RootMotion::FinalIK::FBIKChain::SolveLinearConstraint)> {
  static const MethodInfo* get() {
    static auto* node1 = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolver/Node")->byval_arg;
    static auto* node2 = &::il2cpp_utils::GetClassFromName("RootMotion.FinalIK", "IKSolver/Node")->byval_arg;
    static auto* crossFade = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* distance = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "SolveLinearConstraint", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node1, node2, crossFade, distance});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::ForwardReach
// Il2CppName: ForwardReach
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(UnityEngine::Vector3)>(&RootMotion::FinalIK::FBIKChain::ForwardReach)> {
  static const MethodInfo* get() {
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "ForwardReach", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{position});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::BackwardReach
// Il2CppName: BackwardReach
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RootMotion::FinalIK::FBIKChain::*)(UnityEngine::Vector3)>(&RootMotion::FinalIK::FBIKChain::BackwardReach)> {
  static const MethodInfo* get() {
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RootMotion::FinalIK::FBIKChain*), "BackwardReach", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{position});
  }
};
// Writing MetadataGetter for method: RootMotion::FinalIK::FBIKChain::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
